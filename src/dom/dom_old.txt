#include "main.h"
#include "dom.h"

/* Odom */
void Odom::task() {

}

void Odom::customTask() {
    // create your own odometry implementation. use Odom::task() for reference
}

void Odom::init(Pose start, double linear_offset, double angular_offset) {

}

void Odom::start() {
    // starts task with highest priority (16)
    pros::Task odom_task(Odom::task, NULL, 16, 256, "odom");
}

void Odom::reset(Pose pose) {
    std::lock_guard<std::mutex> lock(Odom::mutex);
    Odom::pose = pose;
}


/* Chassis */
Chassis::Chassis(std::initializer_list<int8_t> left_motors, std::initializer_list<int8_t> right_motors, 
                PIDConst move_PID, PIDConst ang_PID, PIDConst turn_PID, double exit_dist, double exit_angle) {
    this->left_motors = std::make_unique<pros::MotorGroup>(left_motors);
    this->right_motors = std::make_unique<pros::MotorGroup>(right_motors);
    default_move_PID = default_move_PID;
    default_ang_PID = default_ang_PID;
    default_turn_PID = default_turn_PID;
    this->exit_dist = exit_dist;
    this->exit_angle = exit_angle;
}

void Chassis::move(Point p, double max, PID move_PID, PID ang_PID, int direction, double exit) {
    Pose pose = Odom::get();
    double dist = get_dist(p, pose.p());
    double angle = get_angle(p, pose);

    move_PID.reset(dist);
    ang_PID.reset(angle);
    double dt = 10; // ms
  
    while (dist > exit) {
        // update robot pose
        pose = Odom::get();
        // get error to target
        double dist = get_dist(p, pose.p());
        double angle = get_angle(p, pose);

        // determine direction and reverse if neccessary
        if (direction == 0) direction = fabs(angle) > M_PI_2 ? -1 : 1;
        if (direction == -1) angle -= M_PI * (angle > 0 ? 1 : -1);
        
        double move = cos(angle) * direction * move_PID.calc(dist, dt / 1000);
        double ang = ang_PID.calc(angle, dt / 1000);
        arcade(move, ang, max);

        pros::delay(dt);
    }
}
void Chassis::move(Point p, double max, PID move_PID, double exit) {
    move(p, max, move_PID, default_ang_PID, exit);
}
void Chassis::move(Point p, double max, double exit) {
    move(p, max, default_move_PID, exit);
}
void Chassis::move(double distance, double max, PID move_PID, double exit) {
    Point relative = {odom.x + distance * cos(odom.theta), 
                      odom.y + distance * sin(odom.theta)};
    move(relative, max, move_PID, exit);
}
void Chassis::move(double distance, double max, double exit) {
    move(distance, max, default_move_PID, exit);
}

void Chassis::turn(Point p, double max, PID turn_PID, double exit) {
    double angle = get_angle(p, Odom::get());
    turn_PID.reset(angle);
    double dt = 10; // ms
    
    while (angle > exit) {
        pros::delay(dt);
        updateOdom();

        angle = get_angle(p, Odom::get());
        double ang = turn_PID.update(angle, dt / 1000);
        arcade(0, ang, max);
    }
}
void Chassis::turn(Point p, double max, double exit) {
    turn(p, max, default_turn_PID, exit);
}
void Chassis::turn(double angle, double max, PID turn_PID, double exit) {

}
void Chassis::turn(double angle, double max, double exit) {

}



move({10, 20}, 100, {.exit = 2, .lin_PID = {1, 1, 1}, .async = true, .direction = FORWARD});
move({10, 20}, 100, {.exit = 2, .lin_PID = {1, 1, 1}, .direction = FORWARD}, true);

move({10, 20, 90}, 85, {.async = true});

move({10, 20}, 100, NULL, true);

move({10, 20}, 100, {.dir = -1, .thru = true}, true);

chassis.move({10, 20}, 100, {.exit = 5, .thru = true, .async = true, .direction = FORWARD, .timeout = 1000});